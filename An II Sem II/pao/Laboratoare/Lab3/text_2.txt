Semaphores:
--------------

1. Background and Invariants
2. Simple implementation in Java using syncronized keyword.

class Semaphore
{
  private int mVal = 0;
  public Semaphore(int initial) { mVal = initial; }
  public synchronized void myWait() 
  {
    mVal--;
    if (mVal < 0) try { wait(); } 
    catch(InterruptedException e) { }
  }

  public synchronized void mySignal() 
  {
    mVal++;
    if (mVal <=0 ) notify();
  }
}

Sempahore s(3);
//s.myWait();
//s.mySignal();

----------

class Sempahore deja implementata in java:
Func : acquire/tryacquire/release/availablePermits
Obs:   First three func can also accept a parameter representing the number of units to increment/decrement

3. Application 1: Dinning Philosophers
	- N philosophers at a circular table, executes 2 operations in order: THINK then EAT.
	- there are N forks, one between each pair of consecutive philosophers.
	- to EAT a ph needs both forks (left and right fork. If ph has index 0 then he needs fork 0 and fork 1).
	
   TODO: Simulate 10 cycles of THINK+EAT for each ph. 

   Parallelism issues:
	- need to ensure mutual exclusion of forks
	- Can get a deadlock if all ph. get the fork on their left (one one could get the fork on the right anymore)

   Implementation suggestions:
	- Each ph. is a thread (class)
	- To simulate THINK and EAT consider Thread.Sleep(random time) in interval [0,100] ms.
	- Need a sempahore to control how many ph have started the cycle. Initially it should have value N-1 to avoid all N ph enter in cycle at once.	
	- Need binary semaphores for each fork.
	- Have a class Table with static members that can be accessed by ph class: N, all semaphores.

4. Application 2: 

We have a shared object (let's say a database).
There are 2 actors: Readers - read only shared object
		    Writers - read/write modify the shared object

Conditions
-> Multiple readers can access the shared object at the same time
-> Only one writer at any point. When a writer gets access NO READERS should be active.

Obs: Use sempahores for impl. 

Possible operations for actors (calls guaranteed in correct order):
	a) Writers:
		open(WRITE);
		// read content
		close(WRITE);
	b) Readers:
		open(READ);
		// write content
		close(READ);

Pair (numReaders, numWriters) can have valules (0,0), (0,1), (n,0)
A state is represented by (numReaders, numWriters, semaphore) where sempahore is 1 if no one is accessing the resource, 0 otherwise.
Possible states: (0,0,1) , (1,0,0), (0,n,0).
Initial state is (0,0,1). 

Implement 2 solutions:

4.1 Favor readers (solution in ReadersAndWriters)

4.2 Favor writers  (solution in ReadersAndWriters_2)

4.3 Talk about starvation

5. Application 3: Barriers

 a) What is a barrier ?
 b) Check example in folder BarrierExample

CyclicBarrier(int n) or CyclicBarrier(int n, Runnable r) - r is a code that you want to run when everybody gets to the barrier.

 c) How would you implement a barrier ?
Check BarrierExample folder for an implementation.
 
6. Application 4: 
	- Consider 2 arrays A, B with dimensions lA and lB.
	- Target: if C = A U B, at the end of the program A should contain the smallest values while B the highest ones.
	- The only acceptable operation is swapping a value between A and B.

Implement using a barrier. Check folder BarrierMerge for solution.

7. Advanced ReadersAndWriters (no favors, simulation using a queue)

(solution for a) in ReadersAndWriters_3, for b) in ReadersAndWriters_4)

a) Using the implementation for readers, writers and main from ReadersAndWriters folder, change the implementation of 
Database class such that to be fair for both readers and writers.

Idea with "polling" thread:
- Create a queue of persons requesting access to the Database (each item would contain type of access - READ / WRITE - and an empty semaphore - 0 value initially )
- When a person wants access, it will get added to the queue and aquire the semaphore (which being 0, will block there).
- Database must be derived  from a thread and have a run function executed by a separate thread.
  This thread will always get the first element from the queue and call semaphore.release() (which will awake the waiting open operation)
  if the operation is vaid:  Eg. if READ then we must have no writers, if WRITE we must have no readers and writers, so just keep the counts..
- you will also need an internal lock for some operations...

b) Improve the algorithm implemented in a to use condition.

Lock r = new ReetrantLock(true);
Condition cond1 = r.newCondition();
// You can create how many condition you want...

When cond1.wait() is called, it will wait for a cond1.signal() or cond1.signalAll() to be called.
Notice: on wait() the lock r is released. Also, after there is a signal and we pass the wait() we re-aquire the lock automatically.


THreads used to

-> hide latency  (some processes can wait data / sleep) while other compute
-> use computational power available to solve faster a problem


Basic java threads
-------------------

1. Difference between process and thread
2. How different OS schedulers work
3. Priorities, simple example, interrupt
	
	Check SimpleThread app code.

4. Race conditions & Syncronization primitives 
    
a) Check the example in RaceStuff project. 
	
	* Understand code and how shared memory is passed.
	* Run program and check counter. Try to remove "syncronized" word from uncommented Counter class to see the results.
	* Switch to the commented Counter function to see a general syncronization method that doesn't affect entire function.

     Discussion: mutex in java, how these works internally.

b)  Guarded Blocks / wait / notify

App 1: Implement producer - consumer paradigm
	- single item to produce / consume: http://www.tutorialspoint.com/javaexamples/thread_procon.htm
	- using an already syncronized queue (BlockingQueue), multiple consumers & items:
		https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html

	Q: how do you think is BlockingQueue implemented ?
	See other concurrent collections here: https://docs.oracle.com/javase/tutorial/essential/concurrency/collections.html

c) Atomics: https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/package-summary.html

App 2 (histogram): Consider N random numbers in interval [0,M]. Consider K buckets of equal length.
You must compute home many numbers are in each bucket using P threads (worker threads).
(Solution in Histogram project)

	* Generate an array of random numbers as described above
	* Spawn P worker threads to solve this problem.
		- Idea 1: use a single global result histogram and atomic variables.
		- Idea 2: use local histograms (per worker) and combine them all in the end
	* Measure execution time for serial vs parallel execution
	* Try to use a Reduce algorithm: https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html

5. General issues
	- Deadlock: http://www.tutorialspoint.com/java/java_thread_deadlock.htm
		App: See Deadlock  (problem ) and Deadlock_solved (solution)
		How to debug: Press Debug / Project then hit Pause button when it's blocked. Check the callstack (see picture DebugDeadlock.png in main folder).


	- Starvation and livelock: https://avaldes.com/java-thread-starvation-livelock-with-examples/
 	- priority inversion : http://www.drdobbs.com/jvm/what-is-priority-inversion-and-how-do-yo/230600008


5.1 Locks:

	- monitors (syncronized objects) present several disadvantages. Main one: you have to work on the same instance
	- Locks are global similar cu mutex or critical sections in other languages.

Lock:
Lock l = ...;
     l.lock();
     try {
         // access the resource protected by this lock
     } finally {
         l.unlock();
     }

TryLock:
      Lock lock = ...;
      if (lock.tryLock()) {
          try {
              // manipulate protected state
          } finally {
              lock.unlock();
          }
      } else {
          // perform alternative actions
      }

5.2 Reentrant locks

	- same interface with Lock
	- allows timeout for tryLock
	- can set fairness (explain why Lock doesn't have fairness)
	- lockInterruptibly

A few examples: https://dzone.com/articles/using-the-websphere-liberty-application-client

5.3 App: 
	- Avem 2 clase Client1 si Client2, ambele contin un lacat personal.
	- Avem 2 threaduri OpClient1 si OpClient2 ce trebuie sa faca o operatie.
	- Aceasta operatie poate fi efectuata de catre ClientX doar daca detine ambele lacate.

	
5.4 Condition

- Instead of wait/notify,notifyAll => await/signal, signalAll

Lock lacat = new Lock();
Condition c1 = lacat.newCondition();
Condition c2 = lacat.newCondition();
lacat.lock();
     invocari ale metodelor await, signal si signalAll prin c1 si c2
lacat.unlock();

	  
App: Implement multi-producer consumer problem using conditions (see MultiProducerConsumer folder for a solution)


6. Task vs thread parallelism

http://tutorials.jenkov.com/java-util-concurrent/executorservice.html
http://www.journaldev.com/1069/java-thread-pool-example-using-executors-and-threadpoolexecutor

7. Active object pattern
Original doc: http://www.cs.wustl.edu/~schmidt/PDF/Act-Obj.pdf

Java: http://www.drdobbs.com/parallel/prefer-using-active-objects-instead-of-n/225700095
App 3: Implement 
